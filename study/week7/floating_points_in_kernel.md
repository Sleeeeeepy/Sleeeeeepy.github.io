# 커널에서의 부동소수점 연산
커널은 부동소숫점(floating point) 연산을 지원하지 않습니다. 커널이 느리게 작동할 수 있다는 대략적인 이유가 있지만 그것만으로는 부동소수점 연산을 지원하지 않는 것은 이해가 되지 않습니다. 부동소수점은 C 언어에 기본적으로 있기도 하고, 유저 모드에서는 부동소수점 연산을 사용하기도 하기 때문입니다. "Linux Kernel Development"의 저자 Robert Love는 아래와 같이 부동소수점 연산의 실행 과정을 제시합니다.

1. 유저 프로세스에서 부동소수점 연산을 실행할 때 커널은 정수 연산 모드를 부동소수점 연산 모드로 변경합니다.
2. 아키텍처마다 다르지만, 이 과정은 트랩(Trap)을 통해 수행할 수 있는데, 커널은 이 트랩을 포착하여 모드를 변환합니다.
3. 하지만 커널은 자신을 쉽게 트랩할 수 없기 때문에 이 과정이 어렵고, 수동으로 레지스터를 저장하고 복원해야 합니다.

단순히 불편할 뿐만 아니라 위험하기까지 합니다. 약간의 실수만 하더라도 커널이 유저 프로세스의 FPU 레지스터를 오염시킬 가능성이 있습니다. 따라서 이를 처리할 함수가 필요합니다. 리눅스 커널에서는 `kernel_fpu_begin()`, `kernel_fpu_end()`와 같은 함수가 있습니다.

그리고 몇 가지 이유가 더 있습니다. 어떤 프로세서는 부동소수점 연산을 지원하지 않기도 합니다. 이런 환경에서 커널이 부동소수점 연산을 수행한다면 FPU를 모방해야 하기 떄문에 상당히 느리게 작동합니다. 그리고 표준 라이브러리에는 이런 상황에 대비해서 어떤 CPU에서든 프로그램이 정확하게 작동하도록 `__fixfsi`와 같은 부동소수점 연산 루틴이 들어가 있습니다.

즉, 요약하자면 아래와 같습니다.
1. 부동수소점을 사용하기 위해 트랩을 제어하기 어렵다.
2. 부동소수점은 느리다.
3. 어떤 환경에서는 부동소수점을 지원하지 않는다.

## See also
그렇다면 아래 코드는 어떻게 `__fixfsi`에 대한 레퍼런스가 없다는 오류를 낼까요?
``` c
float f = 3.33f;
printf ("%d", (int)f);
```

우선, 컴파일 옵션을 봅시다. 우선 `__fixfsi`는 `float` 타입을 `int` 타입으로 변환하는 함수라는 사실만 유념합니다.
```
CFLAGS = -g -msoft-float -O0 -fno-omit-frame-pointer -mno-red-zone
CFLAGS += -mcmodel=large -fno-plt -fno-pic -mno-sse
CPPFLAGS = -nostdinc -I$(SRCDIR) -I$(SRCDIR)/include/lib -I$(SRCDIR)/include
CPPFLAGS += -I$(SRCDIR)/include/lib/kernel
```
여기에서, 표준 라이브러리를 사용하지 않는다는 사실을 알 수 있습니다.  그리고 soft-float를 활성화 했기 때문에 부동소수점 연산이 `__fixfsi`와 같은 함수의 호출로 변환되고, 이 함수가 현재 include에 존재하지 않으므로 사용할 수 없습니다.

사실 운영체제는 표준 라이브러리를 사용할 수 없습니다. 표준 라이브러리에서 운영체제에 의존하고 있는 부분이 있기 때문입니다. pintos에서는 이 때문에 lib/include에서 표준 라이브러리를 대응하고 있습니다.