# 그래프 알고리즘
## 최소 신장 트리
신장 트리란 그래프 내의 모든 정점을 포함하는 트리를 일컫습니다. 그 중에서도 최소 신장 트리는 가중치의 합이 최소인 신장 트리를 의미합니다. 최소 신장 트리를 찾는 알고리즘은 어떤 그래프에서 모든 정점을 최소 비용으로 잇고 싶을 때 유용하게 사용될 수 있습니다.

### 크루스칼 알고리즘
크루스칼 알고리즘은 탐욕법을 이용해 최소 신장 트리를 만듭니다.
1. 그래프의 간선을 가중치의 오름차순으로 정렬한다.
2. 가장 낮은 가중치의 간선을 선택하면서도, 사이클을 형성하지 않는 간선을 선택한다.
3. 선택된 간선은 이제 최소 신장 트리의 일부이다.

여기서 가장 낮은 가중치의 간선을 선택하는 것은 아주 쉽지만, 사이클을 형성하지 않는 간선인지의 여부를 파악하는 것은 쉽게 생각할 수 없습니다. 2번 과정으로 선택된 간선이 최소 신장 트리에 포함이 되지 않고 다른 경로가 될 수도 있지 않을까요?

#### 새로 추가된 간선이 사이클을 형성하는지에 대한 여부 판단하기
정점의 집합을 두개의 집합 $S$, $V-S$로 나눌 수 있습니다. 이를 **절단**이라고 합니다. 그리고 단절을 통해 나누어진 두 집합에 연결된 간선이 존재하면 두 집합이 **교차**한다고 말합니다. 만약 선택된 간선 중 그러한 간선이 없다면 그 간선의 집합을 **따른다** 라고 표현합니다. 어떤 간선이 절단을 교차하는 간선 중 가중치가 가장 작은 간선을 **경량 간선**이라고 합니다.

정점의 집합을 두개의 집합으로 나누어 봅시다. 하나는 선택된 집합이고, 다른 하나는 선택되지 않은 집합입니다. 만약 새로운 간선을 선택할 때 그 간선의 양 끝이 모두 선택된 집합에 있는 정점을 가리키고 있다면 이는 사이클을 형성할 것입니다. 즉, 우리는 **절단**된 두 집합을 잇는 간선을 찾으면, 그 간선은 사이클을 만들지 않음을 알 수 있습니다.

#### 간선 찾기 
이미 만들어진 최소 신장 트리가 있다고 가정합시다. 그리고 그 신장트리의 아무 곳을 끊어봅시다. 만약 끊어진 곳이 신장 트리를 만드는 유일한 경로라면 반드시 포함되야 함이 자명합니다. 그렇지 않고 신장 트리를 만드는 새로운 경로가 있다고 합시다. 이렇게 새로 만들어진 신장 트리는 다른 부분은 같고 교차하는 간선만 다릅니다. 그러면 새로 만들어진 신장 트리의 가중치의 합은 기존 신장 트리의 가중치의 합보다 작을 수 없습니다. 왜냐하면 우리가 끊은 간선은 경량 간선이기 때문입니다.

#### 유니온-파인드 알고리즘 (서로소 집합 알고리즘)
이제 선택된 노드를 모두 한 집합으로 만들어야 합니다. 어떻게 하면 그렇게 할 수 있을까요? 절단된 두 집합은 기본적으로 서로소 집합입니다. 따라서 서로소 집합을 컴퓨터 상에서 구현하고 사용한다면 구현할 수 있습니다.

``` python
parent = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

def find(x):
    if parent[x] != x:
        return find(parent[x])
    return x

def find_quick(x):
    if parent[x] != x:
        return parent[x] = find_quick(parent[x])
    return parent[x]

def union(a, b):
    a = find(a)
    b = find(b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
```
이 알고리즘에서 주의할 점은 만약 집합을 분리하는 알고리즘이 필요한 문제를 풀 때 반드시 부모에 해당하는 값을 갱신해줘야 합니다. 예를 들어 `0, 1, 2, 3` 노드가 있고 `union(2, 3)`, `union(1, 2)`을 수행하면 `1, 2, 3`은 모두 같은 집합에 속하지만 `parent = [0, 1, 1, 2]`가 됩니다.

만약 후술할 프림 알고리즘과 크루스칼 알고리즘 중에 하나만을 사용해야 한다면 크루스칼 알고리즘을 쓰는 것이 좋습니다. 알고리즘이 구현하기 쉽기 때문입니다. 하지만 몇몇 문제는 풀리지 않는데, 이는 크루스칼 알고리즘은 $O(E \log V)$, 프림 알고리즘은 $O(V^2)$ 혹은 $O((V+E)\log V)$ 혹은 $O(E+V\log V)$의 시간 복잡도를 갖기 때문입니다.
### 프림 알고리즘
프림 알고리즘 또한 크루스칼 알고리즘과 마찬가지로 탐욕적으로 간선을 선택해나가 최소 신장 트리를 완성하는 알고리즘입니다.

정점 하나를 선택하여 집합을 만듭니다. 이제 이 집합과 이어지는 간선 중 가장 작은 것을 찾습니다. 그 간선이 최소 신장 트리를 이루는 간선 중 하나가 됩니다. 이를 `정점의 수 - 1`만큼 반복하면 최소 신장 트리를 만들 수 있습니다.

``` python
def prim(graph):
    key = [sys.maxsize] * len(graph)
    parent = [-1] * len(graph)
    mst_set = [False] * len(graph)
    pq = [(0, 0)]

    key[0] = 0

    while pq:
        _, u = heapq.heappop(pq)
        mst_set[u] = True

        for v in range(len(graph)):
            if graph[u][v] and not mst_set[v] and graph[u][v] < key[v]:
                key[v] = graph[u][v]
                parent[v] = u
                heapq.heappush(pq, (key[v], v))
```
