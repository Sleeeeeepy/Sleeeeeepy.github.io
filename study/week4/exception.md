# 예외
CPU는 연속된 인스트럭션을 실행하지만 `jump`, `call` 등 제어 흐름과 관련이 있는 인스트럭션을 사용하는 것으로 프로그램이 자신의 상태 변화에 반응할 수 있게 만듭니다. 하지만 시스템들은 프로그램의 실행과 관련 없는 시스템의 상태 변화에 대해서도 반응할 수 있어야 합니다. 예를 들어, 프로그램이 디스크의 데이터를 요청하거나, 키보드 입력이 발생하는 상황은 시스템의 상태를 변화시키며 시스템은 이러한 상황에 반응합니다.

시스템은 제어 흐름을 바꾸어 이러한 예외적인 상황을 처리하는데, 이를 예외적인 제어 흐름(exceptional control flow)이라고 합니다. 예외적인 상황은 모든 수준에서 발생하는데, 하드웨어 수준에서 예외가 발생할 수 있고, 운영체제 커널 레벨에서 발생할 수도 있고, 응용 프로그램 수준에서 예외가 발생할 수 있습니다.

특히, 응용 프로그램 수준에서 예외가 발생한 경우, 프로그래머가 특정한 예외 상황이 발생했을 때 그 예외에 대한 제어 흐름을 결정해야합니다. 그렇지 않다면 예상하지 못한 프로그램의 비정상적인 종료를 야기할 수 있습니다.

## 예외의 종류
| 이름 | 발생 원인 | 동기/비동기 | 결과 |
|---|---|---|---|
| Interrupt | I/O 장치의 시그널 | 비동기 | 다음 인스트럭션으로 복귀
| Trap | 의도적인 예외 | 동기 | 다음 인스트럭션으로 복귀
| Fault | 복구 가능성이 있는 예외 | 동기 | 현재 인스트럭션으로 복귀 할 수 있음
| Abort | 복구 할 수 없는 예외 | 동기 | 복귀하지 않음

용어는 책마다 다를 수 있습니다. 일례로 trap의 경우 software interrupt라고 하기도 합니다.

## 예외 처리
응용 프로그램을 실행하는 도중, 0으로 나누거나, 인터럽트가 들어오는 경우 예외 백터(excpetion vector)라고 부르는 점프 테이블을 참조해서 특정 예외를 처리하기 위한 서브루틴(interrupt handler)으로 이동해 예외를 처리합니다. 예외의 처리가 완료되면 프로그램의 다음 인스트럭션으로 제어가 이동합니다.

특히 예외를 처리하는 서브루틴은 인터럽트 핸들러라고 부르는데, 인터럽트 서비스 루틴으로 불리기도 합니다. 그러나 두 용어에는 다음와 같은 차이가 있습니다.

### 인터럽트 핸들러
인터럽트 서비스 루틴을 포함하는 개념입니다. 인터럽트 핸들러는 인터럽트 서비스 루틴뿐만 아니라, 해당 인터럽트를 관리하고 운영체제나 하드웨어와 상호작용하는 추가적인 코드와 데이터를 포함합니다. 인터럽트 핸들러는 시스템 레벨에서 발생하는 인터럽트를 처리하는 데 사용됩니다. 이것은 운영체제나 응용 프로그램과 상호작용하며, 시스템 전체적인 인터럽트 관리를 다룹니다.

### 인터럽트 서비스 루틴
인터럽트가 발생하면 해당 인터럽트의 원인을 분석하고, 그에 따라 필요한 동작을 수행하는 루틴 또는 코드의 집합입니다. 이것은 인터럽트가 감지되면 호출되는 함수 또는 서브루틴입니다. 인터럽트 서비스 루틴은 주로 하드웨어 수준에서 발생하는 인터럽트를 처리합니다. 이러한 루틴은 주로 하드웨어 디바이스와 관련이 있으며, 하드웨어 레벨의 처리를 담당합니다.

## 시스템 콜
트랩이 발생하면 시스템 콜을 호출할 수 있습니다. 예를 들어서 `int 0x80` 인스트럭션, `syscall`, `sysenter`와 같은 명령들을 실행하면 트랩이 발생합니다. 이 경우 제어가 커널에 있는 인터럽트 핸들러로 이동하고, 커널이 해당 시스템 콜을 실행한 뒤 다시 프로그램에 제어를 돌려줍니다.

리눅스 시스템에서는 시스템 콜을 호출하기 전 `%eax` 레지스터에 시스템 콜 번호를 넣고, `%rdi`, `%rsi`, `%rdx`, `%r10`, `%r8`, `%r9`에 여섯 개의 인자를 넣습니다. 그 후 우리가 시스템 콜을 호출하면 커널이 작업을 처리합니다.

예를 들어서 다음과 같은 C 코드가 있다고 가정합시다.

``` c
#include <stdio.h>

int main() {
    printf("hello, world\n");
}
```

이 코드에서 `printf` 함수 내부에서 "1번 파일(stdout)에 "hello, world"를 쓰라" 라는 `write` 시스템 콜을 호출합니다. 

### 여러 프로세스의 처리 방식
> 프로그램을 시스템에서 실행할 때 프로그램이 해당 시스템의 모든 메모리와 프로세서를 혼자 사용하는 것처럼 느껴집니다. 이는 프로세스라는 개념에 의해 이루어집니다. 우리는 프로세스를 실행할 때 제어흐름을 프로세스에 넘긴다는 사실을 알고 있습니다. 그리고 만약 프로세스가 절대 제어흐름을 다시 커널에 넘기지 않는다면 어떻게 될까요? 프로세스가 시스템을 독점적으로 사용하게 될 것입니다. 다행스럽게도 시스템에는 인터럽트가 발생하고, 인터럽트를 처리하기 위해서 문맥 전환을 통해 커널로 제어가 이동합니다. 그런데 인터럽트를 마냥 기다릴 수 없습니다. 만약 I/O가 없거나, 트랩이 없다면 하나의 프로그램이 계속해서 실행될 것입니다. 그래서 컴퓨터에는 일정 시간마다 인터럽트를 보내주는 타이머가 존재합니다. 운영체제는 주로 이 타이머를 통해 프로세스가 언제 실행될 지에 대한 제어를 수행합니다. 

## 시그널
이번에는 소프트웨어에서 보내는 POSIX 시그널에 대해서 알아봅시다. 시그널 또한 소프트웨어 인터럽트 중 하나입니다. 가장 먼저 주요 시그널에 대해서 알아봅시다. 시그널은 보통 번호로 나타냅니다.

| 번호 | 이름 | 기본 행동 | 무시가능 | 설명 |
|---|---|---|---|---|
2 | SIGINT | 종료 | 예 | 키보드 인터럽트 (Ctrl + C)
9 | SIGKILL | 종료 | 아니오 | 프로그램을 죽입니다.
14 | SIGALRM | 종료 | 예 | alarm 함수에 의한 시그널입니다.
15 | SIGTERM | 종료 | 예 | 프로세스를 정상적으로 종료합니다.
17 | SIGCHLD | 무시 | 예 | 자식 프로세스가 종료되거나 멈춘 경우 발생합니다.

`kill` 명령을 이용하면 손쉽게 프로세스에 시그널을 보낼 수 있습니다.
``` bash
kill -signal pid
```

이제 실제로 시그널을 보내기 위해 `ps` 명령어를 사용해봅시다.
``` bash
> ps
  PID TTY           TIME CMD
  690 ttys000    0:00.02 -zsh
 1277 ttys002    0:00.10 /bin/zsh -il

 > kill -9 1277
```
9번 시그널 `SIGKILL`을 1277에 전송하면 현재 열려있는 쉘이 꺼집니다. 운영체제가 쉘로부터 시그널을 받아 쉘을 죽인 것입니다.

쉘이 한 작업을 우리의 프로그램에서도 그대로 할 수 있습니다. `signal.h`에 `kill` 함수를 이용합니다.
```c
#include <signal.h>
#include <sys/types.h>

int kill(pid_t pid, int sig);
```

또한 프로세스는 `SIGKILL`과 같은 몇몇 시그널을 제외하고 기본 동작을 수정할 수 있습니다.
``` c
#include <signal.h>
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```

`signal` 함수에 핸들러 콜백함수를 지정하면 프로세스가 해당 시그널을 받으면 기본 동작을 수행하는 대신, 콜백함수를 실행합니다.