# 링킹
링킹(linking)을 통해 여러 소스 코드로 이루어진 프로그램을 만들 수 있습니다. 그리고 여러 프로그램을 **연결**한 것 처럼 사용할 수 있습니다. 링킹을 이해하기 앞서 프로그램이 어떻게 주소를 바인딩하는지 알아야 합니다.

## 주소 바인딩
만약 어떤 프로그램이 주소 `0x00000000`에 로드되어야 하는데 다른 프로그램도 같은 곳에 로드되어야 한다면 많은 문제가 생깁니다. 따라서 바인딩(binding)은 거의 필수적인 작업 중 하나입니다.

### 컴파일 타임 바인딩
몇몇 코드들은 사전에 메모리 위치가 이미 알려져있다면 절대 주소를 쓰는 코드(absolute code)를 생성할 수 있습니다. 만약 이러한 주소가 변경된다면 반드시 다시 컴파일 해야합니다. 이 주소는 컴파일 타임에 결정되고, 따라서 컴파일 시간 바인딩이라고 부릅니다. 이 때 바인딩되는 라이브러리를 우리는 정적 라이브러리라고 부릅니다.

### 로드 타임 바인딩
만약 이러한 주소가 컴파일 시간에 알려지지 않았다면 컴파일러는 반드시 재배치 가능한 코드(relocatable code)를 생성 해야합니다. 이 코드들은 로드 타임에 바인딩이 이루어집니다. 

### 실행 타임 바인딩
메모리를 적재할 때 한 번에 주소변환을 하지 않고 프로세스의 명령어가 실행되고자 할 때 주소 바인딩이 이루어집니다. 이 때 주소 변환은 하드웨어가 지원합니다. 그리고 공유 라이브러리를 생성해서 여러 프로세스가 하나의 라이브러리를 공유하여 메모리를 절약하기도 합니다. 우리는 이러한 라이브러리를 동적 연결 라이브러리라고 부릅니다. 

참고로 동적 연결 라이브러리가 로드 시간에 같이 로드되기도 합니다

## 링킹과 목적 파일
이제 주소가 변환되는 방법을 알게 되었습니다. 컴파일러는 컴파일 타임 바인딩도 수행하고, 메모리 참조를 조정하기 위해서 재배치 가능한 코드를 생성합니다. 

### 목적 파일
목적 파일에는 세 가지 종류가 있습니다.
1. 재배치 가능한 목적 파일
2. 실행 가능한 목적 파일
3. 공유 목적 파일

재배치 가능한 목적 파일은 다른 재배치 가능 목적 파일과 결합될 수 있는 바이너리 및 데이터를 포함합니다. 실행 가능한 목적 파일은 실행할 수 있는 형태의 목적 파일입니다. 공유 목적 파일은 로드타임, 혹은 런타임에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 재배치 가능한 목적 파일입니다.

### ELF
이러한 목적 파일의 포맷에는 여러 종류가 있지만 리눅스 혹은 유닉스 시스템에서는 ELF 포맷을 사용합니다. 다음은 각 섹션에 대한 설명입니다.

| 섹션 | 설명 |
|---|---|
| .text | 컴파일된 프로그램의 코드 |
| .rodata | 읽기 전용 데이터 |
| .data | 초기화된 전역 변수와 정적 변수 |
| .bss | 초기화 되지 않은 전역 변수와 정적 변수, 실제로는 위치를 표시 |
| .symtab | 전역 변수와 함수에 대한 정보가 담긴 심볼 테이블 |
| .rel.text | 링커가 이 목적 파일을 다른 파일들과 연결할 때 수정되어야 .text 섹션 내의 위치 |
| .rel.data | 전역 변숟글에 대한 재배치 정보 |
| .debug | 디버깅을 위한 심볼 테이블 | 
| .line | .text 섹션 내의 인스트럭션과 소스 프로그램 간의 매핑 | 
| .strtab | 심볼 테이블과 섹션 헤더들에 있는 스트링 테이블 |

## 심볼 해석
링커는 재배치 가능한 목적 파일들의 심볼 테이블로부터 하나의 심볼 정의에 참조를 연결시켜서 심볼 참조를 해석합니다. 컴파일러는 모듈당 단 하나의 지역 심볼 정의만을 허용하기 때문에 지역 심볼에 대해서는 큰 문제가 없습니다. 해당 스코프에 지역 심볼에 대해 중복된 정의가 나타나지 않으면 됩니다. 그러나 파일 여러 개를 합칠 때 전역 심볼에 문제가 생깁니다. 컴파일 단계에서는 중복된 전역 심볼에 대한 문제를 알 수 없습니다. 

### 서로 다른 파일에 중복으로 정의된 함수의 경우
만약 서로 다른 파일에 `main`함수가 둘 다 존재한다면 링커가 에러 메세지를 출력합니다. 

### 같은 파일에 동일한 전역 변수가 두 번 이상 정의된 경우
그리고 같은 파일에 동일한 전역 변수가 두 번 이상 정의되었다면 에러를 냅니다. 이는 아주 명확해 보입니다. 

### 이름이 같은 두 전역 변수가 각각 다른 파일에 정의된 경우
하지만 이 경우에는 링커 에러가 발생하지 않습니다. 아무런 영향이 없는 것이 아니라, 다른 모듈에서 값을 바꿀 수 있는 상황입니다. 이 경우 곤란한 에러가 발생할 가능성이 높습니다. 특히 두 정의의 타입이 다르다면 컴파일러가 에러가 아닌 경고를 냅니다. 따라서 반드시 컴파일러 경고를 무시해서는 안됩니다. 후자는 다행히 경고라도 내지만 전자는 경고도 내지 않기 때문에 조심해야 합니다.

## 정적 라이브러리 링크하기

### 링크
``` bash
gcc main.c ./lib/example.a
```

### 정적 라이브러리 제작
정적 라이브러리를 만들기 위해서 ar 도구를 사용합니다.
``` bash
gcc -c example1.c example2.c
ar rcs exlib1.a example1.o example2.o
```

## 재배치
링커가 심볼 해석 단계를 완료하면 재배치 단계를 시작합니다. 이 단계에서는 입력으로 받은 모듈을 합치고 각 심볼에 런타임 주소를 할당합니다. 재배치는 두 단계로 구성됩니다.

1. 섹션과 심볼 정의를 재배치합니다. 여러 목적 파일의 .data 섹션을 하나로 합칩니다. 다른 섹션에 대해서도 이 작업을 수행합니다. 그러면 모든 인스트럭션과 변수는 유일한 메모리 주소를 가지게 됩니다.
2. 섹션 내 심볼 참조를 재배치합니다. 코드와 모든 심볼 참조를 수정해서 정확한 런타임 주소를 가리키게 합니다.

## 실행 가능한 목적 파일
실행 파일이 완전히 링크되면 앞의 ELF에서 .rel로 시작하는 섹션들은 더 이상 필요하지 않습니다. 그리고 `main`함수의 첫 번째 인스트럭션의 주소인 **진입점**(entry point)을 포함합니다. 

### 실행 가능한 목적 파일의 로딩
만약 쉘에 아래와 같이 입력한다면 무슨 일이 벌어질까요?
``` bash
> ./prog
```
가장 먼저 쉘에서 execve 함수를 호출하여 로더를 호출합니다. 로더는 디스크로부터 프로그램 `prog`를 메모리에 복사하고 이 프로그램의 진입점으로 점프해서 프로그램을 실행합니다.

참고로, 모든 리눅스 프로그램은 다음과 같은 구조를 갖습니다.

```
+------------------+
|  Kernel memory   |
|       ...        |
+==================+         2^48 - 1
|    User stack    |
+------------------+ ⬅ %rsp
|        ↓         |
|                  |
|                  |
+------------------+
|   Memory mapped  |
| region for shared|
|     libraries    |
+------------------+
|                  |
|                  |
|        ↑         |
+------------------+ ⬅ brk
|  Run-time heap   |
+------------------+
|   R/W segment    |
|  (.data, .bss)   |
+------------------+
|                  |
|   Code segment   |
|                  |
+------------------+            0x400000
|                  |
+------------------+            0
```
